ROUTINE ====================== thread_worker in /u/eng/ugrad/joonsoo/CS111/Proj2b/lab2_list.c
   151    200 Total samples (flat / cumulative)
     .      .  434:         exit(2);
     .      .  435:     }
     .      .  436: }
     .      .  437: 
     .      .  438: void *thread_worker(void *id)
---
     .      .  439: {
     .      .  440:     struct timespec start_time, end_time;
     .      .  441:     int i;
     .      .  442:     int num = *((int *)id);
     .      .  443:     for (i = num; i < numThreads * numIterations; i += numThreads)
     .      .  444:     {
     .      .  445:         switch (lockOpt)
     .      .  446:         {
     .      .  447:         case 'm':
     .      .  448:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  449:             {
     .      .  450:                 fprintf(stderr, "clock error\n");
     .      .  451:                 exit(2);
     .      .  452:             }
     .      .  453:             pthread_mutex_lock(&locks[listNum[i]]);
     .      .  454:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  455:             {
     .      .  456:                 fprintf(stderr, "clock error\n");
     .      .  457:                 exit(2);
     .      .  458:             }
     .      .  459:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  460:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  461:             pthread_mutex_unlock(&locks[listNum[i]]);
     .      .  462:             break;
     .      .  463:         case 's':
     .      .  464:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  465:             {
     .      .  466:                 fprintf(stderr, "clock error\n");
     .      .  467:                 exit(2);
     .      .  468:             }
   114    114  469:             while (__sync_lock_test_and_set(&spinlocks[listNum[i]], 1))
     .      .  470:                 ;
     .      .  471:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  472:             {
     .      .  473:                 fprintf(stderr, "clock error\n");
     .      .  474:                 exit(2);
     .      .  475:             }
     .      .  476:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .     30  477:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  478:             __sync_lock_release(&spinlocks[listNum[i]]);
     .      .  479:             break;
     .      .  480:         default:
     .      .  481:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  482:         }
     .      .  483:     }
     .      .  484:     int length = 0;
     .      .  485:     int j;
     .      .  486:     switch (lockOpt)
     .      .  487:     {
     .      .  488:     case 'm':
     .      .  489:         for (j = 0; j < numLists; j++)
     .      .  490:         {
     .      .  491:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  492:             {
     .      .  493:                 fprintf(stderr, "clock error\n");
     .      .  494:                 exit(2);
     .      .  495:             }
     .      .  496:             pthread_mutex_lock(&locks[j]);
     .      .  497:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  498:             {
     .      .  499:                 fprintf(stderr, "clock error\n");
     .      .  500:                 exit(2);
     .      .  501:             }
     .      .  502:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  503:             int subLength = SortedList_length(&listheads[j]);
     .      .  504:             if (subLength < 0)
     .      .  505:             {
     .      .  506:                 fprintf(stderr, "negative length\n");
     .      .  507:                 exit(2);
     .      .  508:             }
     .      .  509:             length += subLength;
     .      .  510:             pthread_mutex_unlock(&locks[j]);
     .      .  511:         }
     .      .  512:         break;
     .      .  513:     case 's':
     .      .  514:         for (j = 0; j < numLists; j++)
     .      .  515:         {
     .      .  516:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  517:             {
     .      .  518:                 fprintf(stderr, "clock error\n");
     .      .  519:                 exit(2);
     .      .  520:             }
     .      .  521:             while (__sync_lock_test_and_set(&spinlocks[j], 1))
     .      .  522:                 ;
     .      .  523:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  524:             {
     .      .  525:                 fprintf(stderr, "clock error\n");
     .      .  526:                 exit(2);
     .      .  527:             }
     .      .  528:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  529:             int subLength = SortedList_length(&listheads[j]);
     .      .  530:             if (subLength < 0)
     .      .  531:             {
     .      .  532:                 fprintf(stderr, "negative length\n");
     .      .  533:                 exit(2);
     .      .  534:             }
     .      .  535:             length += subLength;
     .      .  536:             __sync_lock_release(&spinlocks[j]);
     .      .  537:         }
     .      .  538:         break;
     .      .  539:     default:
     .      .  540:         for (j = 0; j < numLists; j++)
     .      .  541:         {
     .      .  542:             int subLength = SortedList_length(&listheads[j]);
     .      .  543:             if (subLength < 0)
     .      .  544:             {
     .      .  545:                 fprintf(stderr, "negative length\n");
     .      .  546:                 exit(2);
     .      .  547:             }
     .      .  548:             length += subLength;
     .      .  549:         }
     .      .  550:     }
     .      .  551:     SortedListElement_t *lookup;
     .      .  552:     num = *((int *)id);
     .      .  553:     for (i = num; i < numThreads * numIterations; i += numThreads)
     .      .  554:     {
     .      .  555:         int ret;
     .      .  556:         switch (lockOpt)
     .      .  557:         {
     .      .  558:         case 'm':
     .      .  559:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  560:             {
     .      .  561:                 fprintf(stderr, "clock error\n");
     .      .  562:                 exit(2);
     .      .  563:             }
     .      .  564:             pthread_mutex_lock(&locks[listNum[i]]);
     .      .  565:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  566:             {
     .      .  567:                 fprintf(stderr, "clock error\n");
     .      .  568:                 exit(2);
     .      .  569:             }
     .      .  570:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  571:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  572:             if (lookup == NULL)
     .      .  573:             {
     .      .  574:                 fprintf(stderr, "lookup error\n");
     .      .  575:                 exit(2);
     .      .  576:             }
     .      .  577:             ret = SortedList_delete(lookup);
     .      .  578:             if (ret == 1)
     .      .  579:             {
     .      .  580:                 fprintf(stderr, "delete error\n");
     .      .  581:                 exit(2);
     .      .  582:             }
     .      .  583:             pthread_mutex_unlock(&locks[listNum[i]]);
     .      .  584:             break;
     .      .  585:         case 's':
     .      .  586:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  587:             {
     .      .  588:                 fprintf(stderr, "clock error\n");
     .      .  589:                 exit(2);
     .      .  590:             }
    37     37  591:             while (__sync_lock_test_and_set(&spinlocks[listNum[i]], 1))
     .      .  592:                 ;
     .      .  593:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  594:             {
     .      .  595:                 fprintf(stderr, "clock error\n");
     .      .  596:                 exit(2);
     .      .  597:             }
     .      .  598:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .     19  599:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  600:             if (lookup == NULL)
     .      .  601:             {
     .      .  602:                 fprintf(stderr, "lookup error\n");
     .      .  603:                 exit(2);
     .      .  604:             }
     .      .  605:             ret = SortedList_delete(lookup);
     .      .  606:             if (ret == 1)
     .      .  607:             {
     .      .  608:                 fprintf(stderr, "delete error\n");
     .      .  609:                 exit(2);
     .      .  610:             }
     .      .  611:             __sync_lock_release(&spinlocks[listNum[i]]);
     .      .  612:             break;
     .      .  613:         default:
     .      .  614:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  615:             if (lookup == NULL)
     .      .  616:             {
     .      .  617:                 fprintf(stderr, "lookup error\n");
     .      .  618:                 exit(2);
     .      .  619:             }
     .      .  620:             ret = SortedList_delete(lookup);
     .      .  621:             if (ret == 1)
     .      .  622:             {
     .      .  623:                 fprintf(stderr, "delete error\n");
     .      .  624:                 exit(2);
     .      .  625:             }
     .      .  626:         }
     .      .  627:     }
     .      .  628:     return NULL;
     .      .  629: 
---
ROUTINE ====================== thread_worker in /u/eng/ugrad/joonsoo/CS111/Proj2b/lab2_list.c
   151    200 Total samples (flat / cumulative)
     .      .  434:         exit(2);
     .      .  435:     }
     .      .  436: }
     .      .  437: 
     .      .  438: void *thread_worker(void *id)
---
     .      .  439: {
     .      .  440:     struct timespec start_time, end_time;
     .      .  441:     int i;
     .      .  442:     int num = *((int *)id);
     .      .  443:     for (i = num; i < numThreads * numIterations; i += numThreads)
     .      .  444:     {
     .      .  445:         switch (lockOpt)
     .      .  446:         {
     .      .  447:         case 'm':
     .      .  448:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  449:             {
     .      .  450:                 fprintf(stderr, "clock error\n");
     .      .  451:                 exit(2);
     .      .  452:             }
     .      .  453:             pthread_mutex_lock(&locks[listNum[i]]);
     .      .  454:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  455:             {
     .      .  456:                 fprintf(stderr, "clock error\n");
     .      .  457:                 exit(2);
     .      .  458:             }
     .      .  459:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  460:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  461:             pthread_mutex_unlock(&locks[listNum[i]]);
     .      .  462:             break;
     .      .  463:         case 's':
     .      .  464:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  465:             {
     .      .  466:                 fprintf(stderr, "clock error\n");
     .      .  467:                 exit(2);
     .      .  468:             }
   114    114  469:             while (__sync_lock_test_and_set(&spinlocks[listNum[i]], 1))
     .      .  470:                 ;
     .      .  471:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  472:             {
     .      .  473:                 fprintf(stderr, "clock error\n");
     .      .  474:                 exit(2);
     .      .  475:             }
     .      .  476:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .     30  477:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  478:             __sync_lock_release(&spinlocks[listNum[i]]);
     .      .  479:             break;
     .      .  480:         default:
     .      .  481:             SortedList_insert(&listheads[listNum[i]], &elements[i]);
     .      .  482:         }
     .      .  483:     }
     .      .  484:     int length = 0;
     .      .  485:     int j;
     .      .  486:     switch (lockOpt)
     .      .  487:     {
     .      .  488:     case 'm':
     .      .  489:         for (j = 0; j < numLists; j++)
     .      .  490:         {
     .      .  491:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  492:             {
     .      .  493:                 fprintf(stderr, "clock error\n");
     .      .  494:                 exit(2);
     .      .  495:             }
     .      .  496:             pthread_mutex_lock(&locks[j]);
     .      .  497:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  498:             {
     .      .  499:                 fprintf(stderr, "clock error\n");
     .      .  500:                 exit(2);
     .      .  501:             }
     .      .  502:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  503:             int subLength = SortedList_length(&listheads[j]);
     .      .  504:             if (subLength < 0)
     .      .  505:             {
     .      .  506:                 fprintf(stderr, "negative length\n");
     .      .  507:                 exit(2);
     .      .  508:             }
     .      .  509:             length += subLength;
     .      .  510:             pthread_mutex_unlock(&locks[j]);
     .      .  511:         }
     .      .  512:         break;
     .      .  513:     case 's':
     .      .  514:         for (j = 0; j < numLists; j++)
     .      .  515:         {
     .      .  516:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  517:             {
     .      .  518:                 fprintf(stderr, "clock error\n");
     .      .  519:                 exit(2);
     .      .  520:             }
     .      .  521:             while (__sync_lock_test_and_set(&spinlocks[j], 1))
     .      .  522:                 ;
     .      .  523:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  524:             {
     .      .  525:                 fprintf(stderr, "clock error\n");
     .      .  526:                 exit(2);
     .      .  527:             }
     .      .  528:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  529:             int subLength = SortedList_length(&listheads[j]);
     .      .  530:             if (subLength < 0)
     .      .  531:             {
     .      .  532:                 fprintf(stderr, "negative length\n");
     .      .  533:                 exit(2);
     .      .  534:             }
     .      .  535:             length += subLength;
     .      .  536:             __sync_lock_release(&spinlocks[j]);
     .      .  537:         }
     .      .  538:         break;
     .      .  539:     default:
     .      .  540:         for (j = 0; j < numLists; j++)
     .      .  541:         {
     .      .  542:             int subLength = SortedList_length(&listheads[j]);
     .      .  543:             if (subLength < 0)
     .      .  544:             {
     .      .  545:                 fprintf(stderr, "negative length\n");
     .      .  546:                 exit(2);
     .      .  547:             }
     .      .  548:             length += subLength;
     .      .  549:         }
     .      .  550:     }
     .      .  551:     SortedListElement_t *lookup;
     .      .  552:     num = *((int *)id);
     .      .  553:     for (i = num; i < numThreads * numIterations; i += numThreads)
     .      .  554:     {
     .      .  555:         int ret;
     .      .  556:         switch (lockOpt)
     .      .  557:         {
     .      .  558:         case 'm':
     .      .  559:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  560:             {
     .      .  561:                 fprintf(stderr, "clock error\n");
     .      .  562:                 exit(2);
     .      .  563:             }
     .      .  564:             pthread_mutex_lock(&locks[listNum[i]]);
     .      .  565:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  566:             {
     .      .  567:                 fprintf(stderr, "clock error\n");
     .      .  568:                 exit(2);
     .      .  569:             }
     .      .  570:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .      .  571:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  572:             if (lookup == NULL)
     .      .  573:             {
     .      .  574:                 fprintf(stderr, "lookup error\n");
     .      .  575:                 exit(2);
     .      .  576:             }
     .      .  577:             ret = SortedList_delete(lookup);
     .      .  578:             if (ret == 1)
     .      .  579:             {
     .      .  580:                 fprintf(stderr, "delete error\n");
     .      .  581:                 exit(2);
     .      .  582:             }
     .      .  583:             pthread_mutex_unlock(&locks[listNum[i]]);
     .      .  584:             break;
     .      .  585:         case 's':
     .      .  586:             if (clock_gettime(CLOCK_MONOTONIC, &start_time) < 0)
     .      .  587:             {
     .      .  588:                 fprintf(stderr, "clock error\n");
     .      .  589:                 exit(2);
     .      .  590:             }
    37     37  591:             while (__sync_lock_test_and_set(&spinlocks[listNum[i]], 1))
     .      .  592:                 ;
     .      .  593:             if (clock_gettime(CLOCK_MONOTONIC, &end_time) < 0)
     .      .  594:             {
     .      .  595:                 fprintf(stderr, "clock error\n");
     .      .  596:                 exit(2);
     .      .  597:             }
     .      .  598:             wait_time[num] += get_nanosec_from_timespec(&end_time) - get_nanosec_from_timespec(&start_time);
     .     19  599:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  600:             if (lookup == NULL)
     .      .  601:             {
     .      .  602:                 fprintf(stderr, "lookup error\n");
     .      .  603:                 exit(2);
     .      .  604:             }
     .      .  605:             ret = SortedList_delete(lookup);
     .      .  606:             if (ret == 1)
     .      .  607:             {
     .      .  608:                 fprintf(stderr, "delete error\n");
     .      .  609:                 exit(2);
     .      .  610:             }
     .      .  611:             __sync_lock_release(&spinlocks[listNum[i]]);
     .      .  612:             break;
     .      .  613:         default:
     .      .  614:             lookup = SortedList_lookup(&listheads[listNum[i]], elements[i].key);
     .      .  615:             if (lookup == NULL)
     .      .  616:             {
     .      .  617:                 fprintf(stderr, "lookup error\n");
     .      .  618:                 exit(2);
     .      .  619:             }
     .      .  620:             ret = SortedList_delete(lookup);
     .      .  621:             if (ret == 1)
     .      .  622:             {
     .      .  623:                 fprintf(stderr, "delete error\n");
     .      .  624:                 exit(2);
     .      .  625:             }
     .      .  626:         }
     .      .  627:     }
     .      .  628:     return NULL;
     .      .  629: 
---
